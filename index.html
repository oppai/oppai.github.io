<!DOCTYPE HTML>
<html lang="en">
  <head>
    <link rel="shortcut icon" type="image/vnd.microsoft.icon" href="/favicon.ico">
    <link rel="icon" type="image/vnd.microsoft.icon" href="/favicon.ico">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Hello Oppai">
    <meta name="author" content="@kodam/id:oppai">

    <title>kodam's profile</title>
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-KM6KL71CVX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-KM6KL71CVX');
    </script>
    <!-- Importmap for three.js -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>

  <body>
    <div id="canvas-container" style="width: 100%; height: 100vh; overflow: hidden;"></div>
    <script type="module">
      import * as THREE from 'three'; // Import THREE namespace
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; // Updated import path

      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000); // Set a light background color
      const container = document.getElementById('canvas-container');
      container.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(5, 10, 7.5);
      scene.add(directionalLight);

      // Texture loader
      const textureLoader = new THREE.TextureLoader();
      let planeKodam, planeGohst;
      const cardMeshes = []; // Array to hold card meshes

      // Async function to initialize scene elements that depend on textures
      async function initScene() {
          try {
              // Load kodam texture
              const kodamTexture = await textureLoader.loadAsync('assets/kodam.png');
              const kodamAspectRatio = kodamTexture.image.width / kodamTexture.image.height;
              const kodamPlaneHeight = 5;
              const kodamPlaneWidth = kodamPlaneHeight * kodamAspectRatio;
              const kodamGeometry = new THREE.PlaneGeometry(kodamPlaneWidth, kodamPlaneHeight);
              const kodamMaterial = new THREE.MeshStandardMaterial({ 
                  map: kodamTexture, 
                  side: THREE.DoubleSide, 
                  transparent: true, 
                  depthWrite: false,
                  alphaTest: 0.1
              });
              planeKodam = new THREE.Mesh(kodamGeometry, kodamMaterial);
              planeKodam.userData.initialY = planeKodam.position.y;
              planeKodam.userData.time = 0;
              planeKodam.renderOrder = 1;
              scene.add(planeKodam);
          } catch (error) {
              console.error('An error happened loading the kodam texture:', error);
              // Fallback for kodam plane
              const geometry = new THREE.PlaneGeometry(5, 5);
              const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
              planeKodam = new THREE.Mesh(geometry, material);
              scene.add(planeKodam);
          }

          try {
              // Load gohst texture
              const gohstTexture = await textureLoader.loadAsync('assets/gohst.png');
              const gohstAspectRatio = gohstTexture.image.width / gohstTexture.image.height;
              const gohstPlaneHeight = 2; // Adjust size if needed
              const gohstPlaneWidth = gohstPlaneHeight * gohstAspectRatio;
              const gohstGeometry = new THREE.PlaneGeometry(gohstPlaneWidth, gohstPlaneHeight);
              const gohstMaterial = new THREE.MeshStandardMaterial({ 
                  map: gohstTexture, 
                  side: THREE.DoubleSide, 
                  transparent: true, 
                  depthWrite: false,
                  alphaTest: 0.1
              });
              planeGohst = new THREE.Mesh(gohstGeometry, gohstMaterial);
              planeGohst.position.z = -0.1; // Position slightly behind kodam
              planeGohst.position.x = planeGohst.position.x - 1.2;
              planeGohst.userData.initialY = planeGohst.position.y + 2;
              planeGohst.userData.time = Math.PI; // Offset time for different cycle
              planeGohst.renderOrder = 0;
              scene.add(planeGohst);
          } catch (error) {
              console.error('An error happened loading the gohst texture:', error);
              // Fallback for gohst plane
              const geometry = new THREE.PlaneGeometry(4, 4);
              const material = new THREE.MeshBasicMaterial({ color: 0x0000ff });
              planeGohst = new THREE.Mesh(geometry, material);
              planeGohst.position.z = -0.1;
              scene.add(planeGohst);
          }

          // Load cards texture and create card planes
          try {
            const cardsTexture = await textureLoader.loadAsync('assets/cards.png');
            // Ensure texture repeats wrap correctly if needed (usually not for spritesheets)
            // cardsTexture.wrapS = THREE.RepeatWrapping;
            // cardsTexture.wrapT = THREE.RepeatWrapping;

            const cardAspectRatio = 0.65; // Assuming square cards or derive from texture/sprite info
            const cardPlaneSize = 1.0; // Size of each card plane
            const cardPositions = [
                new THREE.Vector3(-2.0, -0.4, 0.1),  // Adjusted Top-Left: More left and down
                new THREE.Vector3(2.0, -0.4, 0.1),   // Adjusted Top-Right: More right and down
                new THREE.Vector3(-1.5, -0.7, 0.1),   // Bottom-Left (unchanged)
                new THREE.Vector3(1.5, -0.7, 0.1),    // Bottom-Right (unchanged)
            ];
            const textureOffsets = [
                { x: 0, y: 0.5 }, // Top-Left card in 2x2 grid
                { x: cardAspectRatio/2 + 0.02, y: 0.5 }, // Top-Right
                { x: 0, y: 0 },    // Bottom-Left
                { x: cardAspectRatio/2 + 0.02, y: 0 },   // Bottom-Right
            ];

            for (let i = 0; i < 4; i++) {
                // Need to clone texture for each material to have independent offset/repeat
                const cardTextureClone = cardsTexture.clone();
                cardTextureClone.needsUpdate = true; // Important after cloning
                cardTextureClone.repeat.set(0.5 * cardAspectRatio, 0.5); // 2x2 grid
                cardTextureClone.offset.set(textureOffsets[i].x, textureOffsets[i].y);

                const cardGeometry = new THREE.PlaneGeometry(cardPlaneSize * cardAspectRatio, cardPlaneSize);
                const cardMaterial = new THREE.MeshStandardMaterial({
                    map: cardTextureClone,
                    side: THREE.DoubleSide,
                    transparent: true,
                    depthWrite: false,
                    alphaTest: 0.1
                });

                const cardMesh = new THREE.Mesh(cardGeometry, cardMaterial);
                cardMesh.position.copy(cardPositions[i]);

                // Animation data
                cardMesh.userData.initialY = cardMesh.position.y;
                cardMesh.userData.initialZ = cardMesh.position.z;
                cardMesh.userData.time = Math.random() * Math.PI * 2; // Random start time
                cardMesh.userData.speed = 0.01 + Math.random() * 0.02; // Random speed
                cardMesh.userData.amplitude = 0.1 + Math.random() * 0.05; // Random amplitude

                cardMesh.renderOrder = 2; // Ensure cards are rendered in front of kodam

                scene.add(cardMesh);
                cardMeshes.push(cardMesh);
            }

          } catch(error) {
              console.error('An error happened loading the cards texture:', error);
              // No fallback for cards for now
          }

          // Start animation loop after attempting to load all
          animate();
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Floating animation for kodam
        if (planeKodam) {
            planeKodam.userData.time += 0.02; // Adjust speed for kodam
            planeKodam.position.y = planeKodam.userData.initialY + Math.sin(planeKodam.userData.time) * 0.2; // Adjust amplitude for kodam
        }

        // Floating animation for gohst
        if (planeGohst) {
            planeGohst.userData.time += 0.025; // Slightly different speed for gohst
            planeGohst.position.y = planeGohst.userData.initialY + Math.sin(planeGohst.userData.time) * 0.4; // Different amplitude for gohst
        }

        // Floating animation for cards
        cardMeshes.forEach(card => {
            card.userData.time += card.userData.speed;
            card.position.y = card.userData.initialY + Math.sin(card.userData.time) * card.userData.amplitude;
        });

        controls.update(); // Required if controls.enableDamping or controls.autoRotate are set to true
        renderer.render(scene, camera);
      }

      // Call the async function to start loading textures and setting up the scene
      initScene();

      // Camera position
      camera.position.z = 7; // Move camera back

      // OrbitControls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 3;
      controls.maxDistance = 20;
      controls.maxPolarAngle = Math.PI / 2; // Prevent looking from below

      // Handle window resize
      window.addEventListener('resize', onWindowResize, false);
      function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      }

    </script>
  </body>
</html>
