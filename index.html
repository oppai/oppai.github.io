<!DOCTYPE HTML>
<html lang="en">
  <head>
    <link rel="shortcut icon" type="image/vnd.microsoft.icon" href="/favicon.ico">
    <link rel="icon" type="image/vnd.microsoft.icon" href="/favicon.ico">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Hello Oppai">
    <meta name="author" content="@kodam/id:oppai">

    <title>kodam's profile</title>
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-KM6KL71CVX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-KM6KL71CVX');
    </script>
    <!-- Importmap for three.js -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <!-- Load three-nebula via script tag (UMD compatibility) -->
    <script src="https://cdn.jsdelivr.net/npm/three-nebula@10.0.3/build/three-nebula.js"></script> 
    <!-- Note: Using .min.js version -->

  </head>

  <body>
    <div id="canvas-container" style="width: 100%; height: 100vh; overflow: hidden;"></div>
    <script type="module">
      import * as THREE from 'three'; // Import THREE namespace
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; // Updated import path

      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000); // Set a light background color
      const container = document.getElementById('canvas-container');
      container.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(5, 10, 7.5);
      scene.add(directionalLight);

      // Texture loader
      const textureLoader = new THREE.TextureLoader();
      let planeKodam, planeGohst;
      const cardMeshes = []; // Array to hold card meshes
      const effectMeshes = []; // Array to hold effect meshes
      let nebulaSystem; // Declare Nebula system variable

      // Async function to initialize scene elements that depend on textures
      async function initScene() {
          try {
              // Load kodam texture
              const kodamTexture = await textureLoader.loadAsync('assets/kodam.png');
              const kodamAspectRatio = kodamTexture.image.width / kodamTexture.image.height;
              const kodamPlaneHeight = 5;
              const kodamPlaneWidth = kodamPlaneHeight * kodamAspectRatio;
              const kodamGeometry = new THREE.PlaneGeometry(kodamPlaneWidth, kodamPlaneHeight);
              const kodamMaterial = new THREE.MeshStandardMaterial({ 
                  map: kodamTexture, 
                  side: THREE.DoubleSide, 
                  transparent: true, 
                  depthWrite: false,
                  alphaTest: 0.1
              });
              planeKodam = new THREE.Mesh(kodamGeometry, kodamMaterial);
              planeKodam.userData.initialY = planeKodam.position.y;
              planeKodam.userData.time = 0;
              planeKodam.renderOrder = 2;
              scene.add(planeKodam);

              // --- Create Aura Particle System AFTER kodam is initialized ---
              const particleCount = 500;
              const particleSize = 0.03; // Keep increased particle size
              const particlesGeometry = new THREE.BufferGeometry();
              const positions = [];
              const colors = [];
              const velocities = []; // Store initial velocities for animation
              const auraColor = new THREE.Color(0xaaaaff); // Bluish-white

              for (let i = 0; i < particleCount; i++) {
                  // Position particles in a sphere around origin (will follow planeKodam in animate)
                  // Adjust radius calculation for denser center
                  const randomFactor = Math.pow(Math.random(), 3); // Power makes smaller values (closer to center) more likely
                  const radius = 1.8 + randomFactor * 1.0; // Keep the range 1.5 to 2.5, but bias towards 1.5

                  const theta = Math.random() * Math.PI * 2;
                  const phi = Math.acos((Math.random() * 2) - 1); // Distribute uniformly on sphere

                  const x = radius * Math.sin(phi) * Math.cos(theta);
                  const y = radius * Math.sin(phi) * Math.sin(theta);
                  const z = radius * Math.cos(phi) - 0.2; // Slightly behind? Adjust as needed.

                  positions.push(x, y, z);

                  // Add slight color variation and set initial alpha to 1.0
                  const variance = Math.random() * 0.3;
                  colors.push(auraColor.r + variance, auraColor.g + variance, auraColor.b + variance, 1.0); // Add alpha = 1.0

                  // Store random velocity/phase for animation
                  velocities.push(
                      (Math.random() - 0.5) * 0.02, // x velocity/phase
                      (Math.random() - 0.5) * 0.02, // y velocity/phase
                      Math.random() * Math.PI * 2   // time offset
                  );
              }

              particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
              // Set color attribute with 4 components (RGBA)
              particlesGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 4)); 
              particlesGeometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3)); // Store velocities in geometry

              const particleMaterial = new THREE.PointsMaterial({
                  size: particleSize, // Use the variable
                  sizeAttenuation: true,
                  vertexColors: true, // Use colors defined in geometry
                  transparent: true,
                  blending: THREE.AdditiveBlending, // Make particles glow when overlapping
                  depthWrite: false, // Helps with transparency issues
              });

              const auraParticles = new THREE.Points(particlesGeometry, particleMaterial);
              auraParticles.userData.initialPositions = particlesGeometry.attributes.position.clone(); // Store initial positions
              auraParticles.renderOrder = 1; // Changed from 2 to 1 (behind kodam, in front of ghost)
              scene.add(auraParticles);
              // --- End Aura Particle System ---

          } catch (error) {
              console.error('An error happened loading the kodam texture:', error);
              // Fallback for kodam plane
              const geometry = new THREE.PlaneGeometry(5, 5);
              const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
              planeKodam = new THREE.Mesh(geometry, material);
              // Ensure fallback planeKodam also has necessary properties if aura depends on them later
              planeKodam.userData.initialY = planeKodam.position.y; 
              planeKodam.userData.time = 0;
              planeKodam.renderOrder = 2; // Keep render order consistent (Changed from 1 to 2)
              scene.add(planeKodam);
          }

          try {
              // Load gohst texture
              const gohstTexture = await textureLoader.loadAsync('assets/gohst.png');
              const gohstAspectRatio = gohstTexture.image.width / gohstTexture.image.height;
              const gohstPlaneHeight = 2; // Adjust size if needed
              const gohstPlaneWidth = gohstPlaneHeight * gohstAspectRatio;
              const gohstGeometry = new THREE.PlaneGeometry(gohstPlaneWidth, gohstPlaneHeight);
              const gohstMaterial = new THREE.MeshStandardMaterial({ 
                  map: gohstTexture, 
                  side: THREE.DoubleSide, 
                  transparent: true, 
                  depthWrite: false,
                  alphaTest: 0.1
              });
              planeGohst = new THREE.Mesh(gohstGeometry, gohstMaterial);
              planeGohst.position.z = -0.1; // Position slightly behind kodam
              planeGohst.position.x = planeGohst.position.x - 1.2;
              planeGohst.userData.initialY = planeGohst.position.y + 2;
              planeGohst.userData.time = Math.PI; // Offset time for different cycle
              planeGohst.renderOrder = 0;
              scene.add(planeGohst);
          } catch (error) {
              console.error('An error happened loading the gohst texture:', error);
              // Fallback for gohst plane
              const geometry = new THREE.PlaneGeometry(4, 4);
              const material = new THREE.MeshBasicMaterial({ color: 0x0000ff });
              planeGohst = new THREE.Mesh(geometry, material);
              planeGohst.position.z = -0.1;
              scene.add(planeGohst);
          }

          // --- Create Effect Planes behind Gohst ---
          try {
              const effectTexture = await textureLoader.loadAsync('assets/effect.png');
              const effectAspectRatio = effectTexture.image.width / effectTexture.image.height;
              const effectPlaneHeight = 3.0; // Adjust size as needed
              const effectPlaneWidth = effectPlaneHeight * effectAspectRatio;
              const effectGeometry = new THREE.PlaneGeometry(effectPlaneWidth, effectPlaneHeight);

              const effectMaterial = new THREE.MeshStandardMaterial({
                  map: effectTexture,
                  side: THREE.DoubleSide,
                  transparent: true,
                  depthWrite: false, // Usually good for transparent effects
                  alphaTest: 0.1,   // Adjust if needed based on texture transparency
                  opacity: 0.7      // Adjust opacity
              });

              // Create two effect planes
              const effectPlane1 = new THREE.Mesh(effectGeometry, effectMaterial.clone()); // Clone material for potential individual changes
              const effectPlane2 = new THREE.Mesh(effectGeometry, effectMaterial.clone());

              // Position behind gohst
              const basePosition = planeGohst ? planeGohst.position.clone() : new THREE.Vector3(0, 0, -0.2); // Fallback position if gohst hasn't loaded
              basePosition.x -= 0.7;
              basePosition.y += 1.0;
              basePosition.z -= 0.1; // Place slightly behind gohst's z

              effectPlane1.position.copy(basePosition);
              effectPlane2.position.copy(basePosition);
              effectPlane2.position.x += 4.0;

              // Rotate the planes
              effectPlane1.rotation.z = Math.PI / 4; // +45 degrees
              effectPlane2.rotation.z = -Math.PI / 4; // -45 degrees

              // Add animation data
              [effectPlane1, effectPlane2].forEach((plane, index) => {
                  plane.userData.initialY = plane.position.y;
                  plane.userData.time = Math.random() * Math.PI * 2; // Random start time
                  plane.userData.speed = 0.015 + Math.random() * 0.01; // Random speed
                  plane.userData.amplitude = 0.15 + Math.random() * 0.05; // Random amplitude
                  plane.renderOrder = -1; // Set render order behind gohst
                  scene.add(plane);
                  effectMeshes.push(plane); // Add to the array
              });

          } catch (error) {
              console.error('An error happened loading the effect texture:', error);
              // No fallback for effect planes for now
          }
          // --- End Effect Planes ---

          // --- Create Nebula Effect from JSON --- 
          const nebulaJSON = {
            "preParticles": 500,
            "integrationType": "EULER",
            "emitters": [
              {
                "id": "51ca9450-3d8b-11e9-a1e8-4785d9606b75",
                "totalEmitTimes": null,
                "life": null,
                "cache": { "totalEmitTimes": null, "life": null },
                "rate": {
                  "particlesMin": 1,
                  "particlesMax": 4,
                  "perSecondMin": 0.01,
                  "perSecondMax": 0.02
                },
                "position": { "x": 0, "y": 0, "z": 0 },
                "rotation": { "x": 0, "y": 0, "z": 0 },
                "initializers": [
                  {
                    "id": "51ca9451-3d8b-11e9-a1e8-4785d9606b75",
                    "type": "Mass",
                    "properties": { "min": 30, "max": 10, "isEnabled": true }
                  },
                  {
                    "id": "51ca9452-3d8b-11e9-a1e8-4785d9606b75",
                    "type": "Life",
                    "properties": { "min": 2, "max": 4, "isEnabled": true }
                  },
                  {
                    "id": "51ca9453-3d8b-11e9-a1e8-4785d9606b75",
                    "type": "BodySprite",
                    "properties": {
                      "texture": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAJkSURBVHjaxJeJbusgEEW94S1L//83X18M2MSuLd2pbqc4wZGqRLrKBsyZhQHny7Jk73xVL8xpVhWrcmiB5lX+6GJ5YgQ2owbAm8oIwH1VgKZUmGcRqKGGPgtEQQAzGR8hQ59fAmhJHSAagigJ4E7GPWRXOYC6owAd1JM6wDQPADyMWUqZRMqmAojHp1Vn6EQQEgUNMJLnUjMyJsM49wygBkAPw9dVFwXRkncCIIW3GRgoTQUZn6HxCMAFEFd8TwEQ78X4rHbILoAUmeT+RFG4UhQ6MiIAE4W/UsYFjuVjAIa2nIY4q1R0GFtQWG3E84lqw2GO2QOoCKBVu0BAPgDSU0eUDjjQenNkV/AW/pWChhpMTelo1a64AOKM30vk18GzTHXCNtI/Knz3DFBgsUqBGIjTInXRY1yA9xkVoqW5tVq3pDR9A0hfF5BSARmVnh7RMDCaIdcNgbPBkgzn1Bu+SfIEFSpSBmkxyrMicb0fAEuCZrWnN89veA/4XcakrPcjBWzkTuLjlbfTQPOlBhz+HwkqqPXmPQDdrQItxE1moGof1S74j/8txk8EHhTQrAE8qlwfqS5yukm1x/rAJ9Jiaa6nyATqD78aUVBhFo8b1V4DdTXdCW+IxA1zB4JhiOhZMEWO1HqnvdoHZ4FAMIhV9REF8FiUm0jsYPEJx/Fm/N8OhH90HI9YRHesWbXXZwAShU8qThe7H8YAuJmw5yOd989uRINKRTJAhoF8jbqrHKfeCYdIISZfSq26bk/K+yO3YvfKrVgiwQBHnwt8ynPB25+M8hceTt/ybPhnryJ78+tLgAEAuCFyiQgQB30AAAAASUVORK5CYII=",
                      "isEnabled": true
                    }
                  },
                  {
                    "id": "51ca9454-3d8b-11e9-a1e8-4785d9606b75",
                    "type": "Radius",
                    "properties": { "width": 6, "height": 2, "isEnabled": true }
                  },
                  {
                    "id": "51ca9455-3d8b-11e9-a1e8-4785d9606b75",
                    "type": "RadialVelocity",
                    "properties": {
                      "radius": 20,
                      "x": 0,
                      "y": 1,
                      "z": -10,
                      "theta": 40,
                      "isEnabled": true
                    }
                  }
                ],
                "behaviours": [
                  {
                    "id": "51ca9456-3d8b-11e9-a1e8-4785d9606b75",
                    "type": "Alpha",
                    "properties": {
                      "alphaA": 1,
                      "alphaB": 0,
                      "life": null,
                      "easing": "easeLinear"
                    }
                  },
                  {
                    "id": "51ca9457-3d8b-11e9-a1e8-4785d9606b75",
                    "type": "Color",
                    "properties": {
                      "colorA": "#002a4f",
                      "colorB": "#0029FF",
                      "life": null,
                      "easing": "easeOutCubic"
                    }
                  },
                  {
                    "id": "51ca9458-3d8b-11e9-a1e8-4785d9606b75",
                    "type": "Scale",
                    "properties": {
                      "scaleA": 0.5,
                      "scaleB": 0.2,
                      "life": null,
                      "easing": "easeLinear"
                    }
                  },
                  {
                    "id": "51ca9459-3d8b-11e9-a1e8-4785d9606b75",
                    "type": "Force",
                    "properties": {
                      "fx": 0,
                      "fy": 1,
                      "fz": -0.2,
                      "life": null,
                      "easing": "easeLinear"
                    }
                  },
                  {
                    "id": "51ca945a-3d8b-11e9-a1e8-4785d9606b75",
                    "type": "Rotate",
                    "properties": {
                      "x": 1,
                      "y": 0,
                      "z": 0,
                      "life": null,
                      "easing": "easeLinear"
                    }
                  },
                  {
                    "id": "51ca945b-3d8b-11e9-a1e8-4785d9606b75",
                    "type": "RandomDrift",
                    "properties": {
                      "driftX": 1,
                      "driftY": 23,
                      "driftZ": 0,
                      "delay": 1,
                      "life": null,
                      "easing": "easeLinear"
                    }
                  },
                  {
                    "id": "51ca945c-3d8b-11e9-a1e8-4785d9606b75",
                    "type": "Spring",
                    "properties": {
                      "x": 1,
                      "y": 5,
                      "z": 0,
                      "spring": 0.01,
                      "friction": 1,
                      "life": null,
                      "easing": "easeLinear"
                    }
                  }
                ],
                "emitterBehaviours": []
              }
            ]
          };

          // --- Load Nebula System from JSON ---
          try {
            nebulaSystem = await Nebula.System.fromJSONAsync(nebulaJSON, THREE);

            // Create the renderer
            const nebulaRenderer = new Nebula.SpriteRenderer(scene, THREE);

            // Add the renderer to the system
            nebulaSystem = nebulaSystem.addRenderer(nebulaRenderer);

            // Set render order, depthWrite and depthTest for Nebula particles
            if (nebulaRenderer.target) {
                nebulaRenderer.target.renderOrder = -2; // Render behind effect planes (-1)
                // Disable depth writing and testing for the particle material
                if (nebulaRenderer.target.material) {
                    nebulaRenderer.target.material.depthWrite = false;
                    nebulaRenderer.target.material.depthTest = false; // Disable depth testing
                } else {
                    console.warn('Could not find Nebula renderer target material to set depthWrite/depthTest.');
                }
            } else {
                console.warn('Could not find Nebula renderer target to set renderOrder/depthWrite/depthTest.');
            }

            // Function to update emitter position based on planeKodam
            nebulaSystem.updateEmitterPosition = (emitter, targetMesh) => {
                if (targetMesh && emitter) {
                    const targetPosition = targetMesh.position.clone();
                    // Adjust the offset based on the new effect's visual center if needed
                    targetPosition.y -= 1.0; // Y offset below kodam
                    // Apply the position copy FIRST
                    emitter.position.copy(targetPosition);
                    // THEN add the Z offset to move the emitter further back
                    emitter.position.z -= 0.5; // Move emitter 0.5 units back in Z
                }
            };

          } catch (error) {
            console.error('Error loading Nebula system from JSON:', error);
          }
          // --- End Nebula Effect from JSON ---

          // Load cards texture and create card planes
          try {
            const cardsTexture = await textureLoader.loadAsync('assets/cards.png');
            // Ensure texture repeats wrap correctly if needed (usually not for spritesheets)
            // cardsTexture.wrapS = THREE.RepeatWrapping;
            // cardsTexture.wrapT = THREE.RepeatWrapping;

            const cardAspectRatio = 0.65; // Assuming square cards or derive from texture/sprite info
            const cardPlaneSize = 1.0; // Size of each card plane
            const cardPositions = [
                new THREE.Vector3(-2.0, -0.4, 0.1),  // Adjusted Top-Left: More left and down
                new THREE.Vector3(2.0, -0.4, 0.1),   // Adjusted Top-Right: More right and down
                new THREE.Vector3(-1.5, -0.7, 0.1),   // Bottom-Left (unchanged)
                new THREE.Vector3(1.5, -0.7, 0.1),    // Bottom-Right (unchanged)
            ];
            const textureOffsets = [
                { x: 0, y: 0.5 }, // Top-Left card in 2x2 grid
                { x: cardAspectRatio/2 + 0.02, y: 0.5 }, // Top-Right
                { x: 0, y: 0 },    // Bottom-Left
                { x: cardAspectRatio/2 + 0.02, y: 0 },   // Bottom-Right
            ];

            for (let i = 0; i < 4; i++) {
                // Need to clone texture for each material to have independent offset/repeat
                const cardTextureClone = cardsTexture.clone();
                cardTextureClone.needsUpdate = true; // Important after cloning
                cardTextureClone.repeat.set(0.5 * cardAspectRatio, 0.5); // 2x2 grid
                cardTextureClone.offset.set(textureOffsets[i].x, textureOffsets[i].y);

                const cardGeometry = new THREE.PlaneGeometry(cardPlaneSize * cardAspectRatio, cardPlaneSize);
                const cardMaterial = new THREE.MeshStandardMaterial({
                    map: cardTextureClone,
                    side: THREE.DoubleSide,
                    transparent: true,
                    depthWrite: false,
                    alphaTest: 0.1
                });

                const cardMesh = new THREE.Mesh(cardGeometry, cardMaterial);
                cardMesh.position.copy(cardPositions[i]);

                // Animation data
                cardMesh.userData.initialY = cardMesh.position.y;
                cardMesh.userData.initialZ = cardMesh.position.z;
                cardMesh.userData.time = Math.random() * Math.PI * 2; // Random start time
                cardMesh.userData.speed = 0.01 + Math.random() * 0.02; // Random speed
                cardMesh.userData.amplitude = 0.1 + Math.random() * 0.05; // Random amplitude

                cardMesh.renderOrder = 3; // Ensure cards are rendered in front of aura

                scene.add(cardMesh);
                cardMeshes.push(cardMesh);
            }

          } catch(error) {
              console.error('An error happened loading the cards texture:', error);
              // No fallback for cards for now
          }

          // Start animation loop after attempting to load all
          animate();
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Floating animation for kodam
        if (planeKodam) {
            planeKodam.userData.time += 0.02; // Adjust speed for kodam
            planeKodam.position.y = planeKodam.userData.initialY + Math.sin(planeKodam.userData.time) * 0.2; // Adjust amplitude for kodam
        }

        // Floating animation for gohst
        if (planeGohst) {
            planeGohst.userData.time += 0.025; // Slightly different speed for gohst
            planeGohst.position.y = planeGohst.userData.initialY + Math.sin(planeGohst.userData.time) * 0.4; // Different amplitude for gohst
        }

        // Floating animation for cards
        cardMeshes.forEach(card => {
            card.userData.time += card.userData.speed;
            card.position.y = card.userData.initialY + Math.sin(card.userData.time) * card.userData.amplitude;
        });

        // Floating animation for effect planes
        effectMeshes.forEach(effect => {
            effect.userData.time += effect.userData.speed;
            effect.position.y = effect.userData.initialY + Math.sin(effect.userData.time) * effect.userData.amplitude;
        });

        // --- Update Nebula System ---
        if (nebulaSystem) {
            // Update emitter position to follow planeKodam
            const fireEmitter = nebulaSystem.emitters[0]; // Assuming the fire emitter is the first one
            nebulaSystem.updateEmitterPosition(fireEmitter, planeKodam);
            
            nebulaSystem.update();
        }
        // --- End Update Nebula System ---

        // --- Animate Aura Particles ---
        const aura = scene.children.find(child => child instanceof THREE.Points); // Find the particles
        if (aura && planeKodam) { // Ensure planeKodam exists
            // Make aura follow kodam's position
            aura.position.copy(planeKodam.position); 
            // Optional: Adjust aura's relative position slightly if needed
            // aura.position.y -= 0.2; // Example: Slightly lower the aura center

            const positions = aura.geometry.attributes.position;
            const colorsAttribute = aura.geometry.attributes.color; // Get color attribute
            const initialPositions = aura.userData.initialPositions;
            const velocities = aura.geometry.attributes.velocity; // Get velocities
            const time = Date.now() * 0.0015; // Increase animation speed slightly

            // Animate material opacity for sparkling effect - REMOVED
            // aura.material.opacity = Math.abs(Math.sin(time * 2.0)); 

            for (let i = 0; i < positions.count; i++) {
                const ix = initialPositions.getX(i);
                const iy = initialPositions.getY(i);
                const iz = initialPositions.getZ(i);

                const vx = velocities.getX(i); // Use stored velocity/phase x
                const vy = velocities.getY(i); // Use stored velocity/phase y
                const timeOffset = velocities.getZ(i); // Use stored time offset

                // --- Restore animation, remove drift ---
                // Simple oscillation (adjust complexity as needed)
                // Increase frequency by multiplying time inside sin/cos
                positions.setX(i, ix + Math.sin(time * 1.5 + timeOffset) * 0.12); // Faster frequency, slightly larger amplitude
                positions.setY(i, iy + Math.cos(time * 1.5 + timeOffset) * 0.12); // Faster frequency, slightly larger amplitude
                // positions.setZ(i, iz); // Keep Z the same or animate it too
                // --- ---

                // --- Animate individual particle alpha ---
                const alpha = Math.abs(Math.sin(time * 2.0 + timeOffset)); // Calculate individual alpha
                colorsAttribute.setW(i, alpha); // Set the 4th component (alpha) of the color attribute
                // --- ---

                // Optional: Animate opacity via material or individual alpha attribute
                // For material opacity: aura.material.opacity = Math.abs(Math.sin(time * 0.5)); // Replaced by the line above
            }
            // Ensure positions are set at least once if animation is disabled
            // If particles still don't show, the issue might be initial positioning or material/rendering.
            positions.needsUpdate = true; // Restore this line as positions are updated again
            colorsAttribute.needsUpdate = true; // IMPORTANT: Tell three.js to update colors attribute
            // --- No need to update positions if they are not changed ---

            // Optional: Animate overall rotation or scale of the aura
            // aura.rotation.y += 0.001;
        }
        // --- End Animate Aura Particles ---

        controls.update(); // Required if controls.enableDamping or controls.autoRotate are set to true
        renderer.render(scene, camera);
      }

      // Call the async function to start loading textures and setting up the scene
      initScene();

      // Camera position
      camera.position.z = 7; // Move camera back

      // OrbitControls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 3;
      controls.maxDistance = 20;
      controls.maxPolarAngle = Math.PI / 2; // Prevent looking from below

      // Handle window resize
      window.addEventListener('resize', onWindowResize, false);
      function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      }

    </script>
  </body>
</html>
